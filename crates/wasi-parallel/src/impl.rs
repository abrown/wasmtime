//! This module translates the calls from the Wasm program (running inside a
//! Wasm engine) into something usable by [WasiParallelContext] (running inside
//! the Wasm runtime). Wiggle performs most of the conversions using
//! `from_witx!` in `witx.rs` but the special nature of `parallel_for` (it can
//! call back into a function in the Wasm module) involves a manual
//! implementation of this glue code.
use crate::context::{Kernel, WasiParallelContext, WasmRunnable};
use crate::witx::types::{
    Buffer, BufferAccessKind, BufferData, BufferSize, DeviceKind, ParallelDevice,
};
use crate::witx::wasi_ephemeral_parallel::WasiEphemeralParallel;
use crate::{WasiParallel, WasiParallelError};
use wasmtime::{Caller, Extern, Func, Memory, Trap, Val};

impl WasiEphemeralParallel for WasiParallel {
    fn get_device(&mut self, hint: DeviceKind) -> Result<ParallelDevice, WasiParallelError> {
        let id = self.ctx.borrow().get_device(hint)?;
        Ok(ParallelDevice::from(id))
    }

    fn create_buffer(
        &mut self,
        device: ParallelDevice,
        size: BufferSize,
        kind: BufferAccessKind,
    ) -> Result<Buffer, super::WasiParallelError> {
        let id = self
            .ctx
            .borrow_mut()
            .create_buffer(device.into(), size as i32, kind)?;
        Ok(Buffer::from(id))
        // TODO change type to `u32`: parameters `device_d` and `size`, returned
        // buffer ID
    }

    fn write_buffer<'a>(
        &mut self,
        data: &BufferData<'a>,
        buffer: Buffer,
    ) -> Result<(), super::WasiParallelError> {
        let mut ctx = self.ctx.borrow_mut();
        let buffer = ctx.get_buffer_mut(buffer.into())?;
        buffer.write(*data)?;
        Ok(())
    }

    fn read_buffer<'a>(
        &mut self,
        buffer: Buffer,
        data: &BufferData<'a>,
    ) -> Result<(), super::WasiParallelError> {
        let ctx = self.ctx.borrow_mut();
        let buffer = ctx.get_buffer(buffer.into())?;
        buffer.read(*data)
    }

    // `parallel_for` is implemented below and manually linked in `lib.rs`.
}

// A manual implementation of the code generated by `impl witx::Bindgen for
// Rust` in `wiggle_generate::funcs`; the directives for what to emit come from
// the implementation of `witx::abi::InterfaceFunc`. This has several
// modifications from the auto-generated version, marked with comments below.
pub fn parallel_for(
    // Change: this argument was `&mut (impl WasiEphemeralParallel +
    // UserErrorConversion)` but here we assume it has been transformed into the
    // type of the actual implementation.
    ctx: &mut WasiParallelContext,
    memory: &dyn wiggle::GuestMemory,
    // Change: assume that a function index has been transformed into a
    // runnable kernel.
    arg0: (i32, WasmRunnable),
    arg1: i32,
    arg2: i32,
    arg3: i32,
    arg4: i32,
    arg5: i32,
    arg6: i32,
) -> Result<i32, wiggle::Trap> {
    use crate::witx::types::*;

    // Change: do not cast these arguments with `as u32`.
    let num_threads = arg1;
    let block_size = arg2;
    // Change: previously `...<[Buffer]>`, we rely on the generated definition
    // of a buffer (i.e., `struct Buffer(u32)`) to avoid some conversion.
    let in_buffers = wiggle::GuestPtr::<[i32]>::new(memory, (arg3 as u32, arg4 as u32));
    let out_buffers = wiggle::GuestPtr::<[i32]>::new(memory, (arg5 as u32, arg6 as u32));

    // Add the SPIR-V to the kernel function; avoid clone (TODO)
    let kernel = Kernel::new(arg0.1, ctx.get_spirv(arg0.0).cloned());

    // Change: instead of calling the trait implementation, we call the context
    // directly.
    let ret = ctx.invoke_parallel_for(
        kernel,
        num_threads,
        block_size,
        &*in_buffers.as_slice()?,
        &*out_buffers.as_slice()?,
    );

    return Ok(match ret {
        Ok(_e) => <ParErrno as wiggle::GuestErrorType>::success() as i32,
        // Change: we do not have the right context type here so we cannot use
        // the generated `... =>
        // UserErrorConversion::par_errno_from_wasi_parallel_error(ctx, e)? as
        // i32`.
        Err(e) => panic!("Failed to run parallel_for: {}", e),
    });
}

/// Retrieve the exported `"memory"` from the `Caller`; this is a helper
/// implementation for simplifying the `parallel_for` closure. Usually this is
/// auto-generated inline by `wiggle_generate::wasmtime::generate_func`.
pub(crate) fn get_exported_memory<T>(caller: &mut Caller<T>) -> Result<Memory, Trap> {
    match caller.get_export("memory") {
        Some(Extern::Memory(m)) => Ok(m),
        _ => Err(Trap::new("missing required memory export")),
    }
}

/// Retrieve a function from the exported `"table"`; this is a helper
/// implementation for simplifying the `parallel_for` closure.
pub(crate) fn get_exported_table_function<T>(
    caller: &mut Caller<T>,
    function_index: u32,
) -> Result<Func, Trap> {
    let table = match caller.get_export("__indirect_function_table") {
        Some(Extern::Table(t)) => t,
        _ => {
            return Err(Trap::new(
                "wasi-parallel requires a '__indirect_function_table' export",
            ))
        }
    };

    match table.get(caller, function_index) {
        Some(Val::FuncRef(Some(f))) => Ok(f),
        _ => {
            return Err(Trap::new(
                "the '__indirect_function_table' export does not contain a funcref at the given index",
            ));
        }
    }
}
